로그인 없는 장바구니 기능을 만들어보자.

1. 데이터 타입은 Hash를 사용한다.
2. 특정 사용자의 장바구니가 사용된지 3시간이 지나면 삭제되도록 조정한다.
3. 장바구니에 물품 조정, 장바구니 조회 기능이 존재한다.
    1. 특별한 Entity의 추가 구현 없이, 대상 물품과 수량은 클라이언트가 정해서 전달한다고 가정하자.
    2. 만약 수량을 줄이고 싶다면 음수가 전달되며,
    3. 수량이 0 이하가 되면 장바구니에서 제거된다.
4. 여러 애플리케이션 인스턴스에 걸쳐 부하가 분산됨을 가정하자.

----------------------------------------------------------------


### Redis 기반 세션 클러스터링 설계
- 여러 애플리케이션 인스턴스에서 Redis 세션을 공유하며, HTTP 세션 ID를 활용해 각 사용자의 장바구니를 식별합니다.
- Cart DTO와 CartItemDTO를 활용하여 장바구니 상태를 클라이언트에게 전달하고, 장바구니 수정 시에도 이 구조를 적용합니다.
- 컨트롤러는 modify-cart, get-cart 두 엔드포인트로 구성되어 있으며, HTTP 세션에서 Session.GetId를 적용해 Redis의 세션 ID를 기반으로 데이터를 관리합니다.
- Redis Template의 Hash Operations 활용 방식이 예시 코드로 설명되고 있습니다.

### 장바구니 DTO와 Redis를 활용한 데이터 처리 방식
- ModifyCart와 GetCart 메서드는 각각 장바구니 상태 수정 및 조회 기능을 제공하며, 수정 후 곧바로 변경된 장바구니 상태를 보여줍니다.
- 서비스에서는 자주 사용하는 키 스트링을 분리하고, Redis Template 및 Hash Operations를 별도로 초기화해 효율적으로 관리합니다.
- 장바구니 수량 증감은 hashOps.increment를 활용하여 처리하며, 이는 Hash 내 필드 값을 증가 또는 감소시키는 방식으로 동작합니다.
- Redis의 특징으로, 키나 필드가 존재하지 않으면 0으로 간주해 새로 생성하여 값을 올리기 때문에 사용이 간단합니다.
- hashOps.get 등 조회 결과가 null일 수 있으므로 Optional.ofNullable로 감싸 0을 반환하게 처리하고, 값이 0 이하일 경우 자동으로 데이터를 삭제합니다.

### 장바구니 API 엔드포인트 동작과 세션 관리 방식
- modify-cart와 get-cart 엔드포인트는 비슷한 구조로 설계되어 있으며, 세션 ID를 기반으로 장바구니 데이터를 관리합니다.
- Boolean 값의 반환에 대해 wrapper-class인 Boolean을 사용하고, nullable false 설정을 통해 명확한 데이터 처리를 합니다.
- 장바구니의 만료 시간(expire At)은 현재 시각에 3시간을 더한 값으로 설정되어 관리하며, 이 설정은 초 단위(seconds)로 변경하여 테스트할 수 있습니다.
- 카트가 비어 있는 상태(모든 필드가 삭제된 시점)에서는 해당 세션 키도 삭제되어, 엔드포인트 호출 시 404 Not Found를 반환하게 됩니다.
- API 실사용에서는 사용자 ID 등 별도 인증 값 없이 세션만으로 장바구니를 요청/수정할 수 있으며, Postman 등을 사용한 테스트에서 정상 동작(상품 추가/감소)이 확인됩니다.

#### Postman
- Postman에서도 쿠키를 저장할 수 있으며, 삭제 후 요청을 실행하면 새로운 세션이 생성됩니다.
- 세션이 만료(expire)되면 Redis에서도 세션과 연관된 Cart 데이터가 함께 사라집니다.
- Cart 데이터는 세션과 함께 약 30초 이내에 사라지며, 다시 데이터를 추가하면 문제없이 재생성됩니다.
- get cart 요청이 포트 8080 또는 8081 어디로 가더라도 동일한 결과가 반환되어 세션 클러스터링의 목표가 달성됩니다.
하지만 세션 만료 시간(expire time)이 서버별로 다를 수 있으므로, 데이터가 균일하게 유지되지 않을 위험이 있으니 주의해야 합니다.